# Error Handling + Observability Gaps (client up/down flow)

This note documents the current usability issues observed around `rpa client up`,
`rpa status`, and `rpa logs`, and proposes a staged improvement plan.

## Repro (as reported)

1) Run `rpa client up` and see `launchd loaded`.
2) Run `rpa status` and the client is not running.
3) Run `rpa client up` again and get `launchctl bootstrap failed`.
4) `rpa logs client` shows nothing; only `rpa client run` surfaces auth failure.

## Current Behavior and Why It Happens

1) **"launchd loaded" is not a health check.**
   - `client up` only writes the plist and calls `launchctl bootstrap`, then prints
     success immediately.
   - There is no readiness check that the client process actually started or that
     the IPC socket is available.
   - Code: `internal/cli/cli.go` (`runClientUp`)

2) **`launchctl bootstrap` fails when the job is already loaded.**
   - The second `client up` run can fail because the job is already bootstrapped
     or in a bad state; the raw error is surfaced without guidance.
   - There is no "already loaded" detection, no `bootout`/`kickstart` recovery,
     and no "run `client down` first" hint.
   - Code: `pkg/launchd/launchd.go` (`Bootstrap`)

3) **Status relies on IPC; no fallback when process is down.**
   - `rpa status` uses the Unix socket IPC. If the process never started or died,
     the socket is absent and status prints "not running".
   - That message does not include any launchd state or last failure detail.
   - Code: `pkg/ipc/client/client.go` (`friendlyDialError`), `internal/cli/cli.go`

4) **Logs command is IPC-only, so it fails when the process is down.**
   - `rpa logs client` reads in-memory ring buffer via IPC only. If the process
     is not running, you get a query error and no logs.
   - The file-backed log (`~/.rpa/logs/client.log`) is not used as a fallback.
   - Code: `internal/cli/cli.go` (`printRecentClientLogs`)

5) **Early startup errors can be dropped.**
   - When running under launchd, stdout/stderr are not redirected anywhere.
   - If the client exits before the logger is initialized (config validation,
     executable resolution), those messages are lost.
   - Code: `pkg/launchd/launchd.go` (`renderPlist` has empty StdoutPath/StderrPath)

6) **Auth failures are terminal but not persisted for later inspection.**
   - SSH auth failures are classified as `auth` and the supervisor stops.
   - After exit, there is no persistent "last error" file to show in `status`.
   - The only reliable trace is the log file, which is not surfaced by `logs`
     when IPC is down.
   - Code: `pkg/sshutil/sshutil.go`, `internal/supervisor/supervisor.go`

## User Impact

- "success" messaging in `client up` is misleading; it does not imply a working tunnel.
- Recovery is non-obvious (status fails, logs fail, bootstrap fails).
- Auth failures look like silent service failure when running under launchd.
- Error handling appears inconsistent depending on whether `client run` or `client up`
  is used.

## Staged Improvement Plan

### Phase 1: Observability Baseline (quick wins)

- **Logs fallback:** when IPC queries fail, fall back to tailing the log file
  (`~/.rpa/logs/client.log` / `agent.log`). If the file is missing, print the
  exact log path so the user can verify it.
- **Explicit messaging:** change `client up` output to say "launchd loaded"
  and "not verified". Suggest `rpa status` and `rpa logs client`.
- **Launchd stdout/stderr:** set `StandardOutPath` and `StandardErrorPath`
  to the same log file so early errors are captured.
- **Surface last 1-2 stderr lines** when startup fails (use the existing
  stderr summary in `internal/supervisor/supervisor.go`).

### Phase 2: Service Readiness Checks

- After `launchctl bootstrap`, poll for the IPC socket (short timeout).
- If the socket does not appear, query `launchctl print` and show the job state.
- If the job exited quickly, auto-print the last few lines of the log file.

### Phase 3: Resilient "up" Semantics

- Detect "already loaded" and perform a safe recovery path:
  - `launchctl bootout` then re-`bootstrap`, or
  - `launchctl kickstart -k` to restart an existing job.
- If recovery fails, print a clear next step (`rpa client down`).

### Phase 4: Persisted Failure Context

- Persist `last_exit`, `last_class`, `last_trigger`, and a short error summary
  to a small state file on each exit.
- `rpa status` should read this state when IPC is unavailable.
- This makes auth failures visible even when the process is not running.

### Phase 5: UX Improvements and Guardrails

- Offer `rpa doctor client` automatically when `client up` fails.
- Provide actionable hints based on `last_class`:
  - `auth`: check key, user, permissions
  - `hostkey`: run `ssh` once to accept host key
  - `dns`: check hostname
  - `timeout/refused`: check network / firewall

## Success Criteria

- `client up` only reports "ready" when the socket is reachable.
- `rpa status` shows a meaningful error even when the service is down.
- `rpa logs client` always shows something useful (IPC or file).
- Auth failures are visible without requiring `client run`.
